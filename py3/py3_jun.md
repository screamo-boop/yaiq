## 1. Что такое "mutable" и "immutable" объекты в Python? Приведи примеры каждого типа.

<details>
  <summary>Ответ</summary>

  ```
  mutable/immutable обозначает изменяемость или неизменяемость обьекта соответственно.
  Данное свойство обьекта указывает, подлежит ли он модификации после инициализации, во время 
  выполнения программы.
  Например, обьекты типа list, dict, set поддерживает операции добавления/удаления элементов, 
  соответственно, является mutable.
  В то же время, обьекты типа tuple или frozenset инициализируются один раз и не могут быть изменены.
  immutable обьекты можно использовать в качестве ключей, в словарях или множествах, так как они 
  хэшируются.
  ```
</details>

## 2. Чем is отличается от ==? Когда использовать каждое из них?

<details>
  <summary>Ответ</summary>

  ```
  is проверяет, являются ли обе переменных одним обьектом в памяти, а == проверяет, равны ли 
  значения обьектов.
  is используется в том случае, когда нужно проверить, являются ли две переменных одним и тем же 
  обьектом, а == когда нужно проверить содержимое переменных.

  Пример:
  a = [1, 2, 3]
  b = [1, 2, 3]
  print(a is b) # False
  print(a == b) # True
  ```
</details>

## 3. Что такое списковое включение (list comprehension)? Напиши пример, в котором ты создаешь список квадратов чисел от 0 до 9.

<details>
  <summary>Ответ</summary>

  ```
  list comprehension - специальная синтаксическая конструкция, которая позволяет заполнить список 
  при помощи цикла for.

  Пример:
  squares = [i**2 for i in range(10)]
  print(squares) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  ```
</details>

## 4. Что произойдет, если изменить изменяемый объект, переданный в функцию как аргумент? Объясни на примере.

<details>
  <summary>Ответ</summary>

  ```
  Если передать изменяемый обьект в функцию, то изменения, сделанные внутри функции, сохранятся за 
  ее пределами.

  Пример:
  def change_list(lst):
    lst.append(4)

  lst = [1, 2, 3]
  change_list(lst)
  print(lst) # [1, 2, 3, 4]
  ```
</details>

## 5. Что делает ключевое слово global и чем оно отличается от nonlocal? Приведи пример.

<details>
  <summary>Ответ</summary>

  ```
  Ключевое слово global, позволяет изменять переменную на уровне функции, так, будто она определена 
  на уровне модуля.
  Если переменной не существует на уровне модуля -- ключевое слово global ее создаст.

  Пример:
  def change_global():
    global x
    x = 10

  change_global()
  print(x) # 10

  Ключевое слово nonlocal позволяет получить доступ к переменной из родительской функции во 
  вложенной функции.
  Для того, чтобы использовать nonlocal во вложенной функции -- переменная обязательно должна быть 
  определена в родительской функции.

  Пример:
  def outer():
    x = 10
    def inner():
      nonlocal x
      x = 20
      print(x)
    inner()
  outer() # 20
  ```
</details>

## 6. Как работает механизм обработки исключений в Python? Какой синтаксис используется? Приведи пример, где обрабатывается ZeroDivisionError.

<details>
  <summary>Ответ</summary>

  ```
  Для обработки исключеий в python используется конструкция try-except.
  Код, описанный в блоке try: будет выполнен в первую очередь.
  Если при выполнении кода в блоке try выпадет исключение -- будет выполнен код, в блоке except.
  В блоке except можно указывать конкретные исключения. 
  Если их не указывать -- будет поймано любое выпавшее исключение.
  Лучшей практикой является указание конкретных исключений, так как except без определения 
  исключения может замедлять выполнение программы, при возникновении исключений.
  Блоков except может быть несколько, в каждом из них можно описать код для обработки конкретного 
  исключения.
  Кроме того, можно описать блок finnaly: 
  Код в этом блоке будет выполнен в последнюю очередь, независимо от того, выпало исключение или нет.
  Также для исключений допустимо использовать else:
  Код внутри блока else будет выполнен, если исключений не было.

  Пример:
  try:
    x = 1 / 0
  except ZeroDivisionError:
    print("На 0 делить нельзя!")
  ```
</details>

## 7. Что такое декоратор в Python? Для чего они применяются? Приведи простой пример.

<details>
  <summary>Ответ</summary>

  ```
  Декоратор является оберткой для функции, позволяющей расширить ее функционал без внесения 
  изменений в код функции.
  Декоратор достаточно определить один раз, после чего его можно использовать над каждой функцией, 
  поведение которой необходимо изменить

  Пример:
  def upper(func):
    def wrapper():
        orig = func()
        ret = orig.upper()
        return ret
    return wrapper

@upper
def print_hello():
  return "Hello World"

  Получается конструкция, аналогичная
  print_hello = upper(print_hello)
  ```
</details>

## 8. Объясни, как работает __init__, и чем он отличается от __new__.

<details>
  <summary>Ответ</summary>

  ```
  Метод __init__ используется для инициализации атрибутов нового экземпляра класса, а __new__ 
  используется для создания экземпляра класса.
  Метод __new__ нужен, в основном, при наследовании от immutable типов, так как immutable обьекты не 
  могут быть изменены после создания. Следовательно, использование __init__ при наследовании от 
  immutable типа бессмысленно, его нельзя изменить после создания.
  ```
</details>

## 9. Что такое генератор (generator)? Чем он отличается от обычной функции? Напиши пример.

<details>
  <summary>Ответ</summary>

  ```
  Генератор -- функция, которая возвращает последовательные значения при помощи ключевого слова 
  yeild.
  Главной особенностью генераторов является то, что они могут вставать на паузу и не держать в 
  памяти полный список значений, в отличии от итерируемых обьектов.
  Например, генератор

  def gen():
    for i in range(10):
      yield i
  будет занимать памяти меньше, чем

  def gen():
    for i in range(10):
      return i
  ```
</details>

## 10. Какие структуры данных есть в стандартной библиотеке Python для хранения уникальных элементов, и в чем особенности их использования?

<details>
  <summary>Ответ</summary>

  ```
  Для хранения уникальных элементов используется set или frozenset.
  Поиск по таким элементам происходит очень быстро, за счет того, что каждый элемент хэшируемый.
  В отличии от списков, set убирает дубликаты, но не сохраняет порядок добавления (в версии до 3.6, начиная с версии 3.7 порядок сохраняется, но это не гарантируется спецификацией)
  ```
</details>